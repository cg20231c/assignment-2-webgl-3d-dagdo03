<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Application</title>
</head>

<body>
    <canvas id="glCanvas" width="800" height="500"></canvas><!-- Include the gl-matrix library from cdnjs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.4.0/gl-matrix.js"></script>
    <script>
        // Set up the canvas
        const canvas = document.getElementById('glCanvas');

        // Initialize WebGL context
        const gl = canvas.getContext('webgl');

        // Define cube vertices
        const planeVertices = new Float32Array([
            -7.0, 0.0, -12.0,
            7.0, 0.0, -12.0,
            7.0, 0.0, 12.0,
            -7.0, 0.0, 12.0,

        ]);

        const letterVertices = new Float32Array([
        -1.5, 0, 0, //0
            1, 0, 0, //1
            1, 0, 2, //2
            -1.5, 0, 2, //3
            1, 0, 0, //4
            1, 0, 2, //5
            1, 2, 2, //6
            1, 2, 0, //7
            -1, 2, 0, //8
            1, 2, 0, //9
            1, 2, 2, //10
            -1, 2, 2, //11
            -1, 2, 0, //12
            -1, 2, 2, //13
            -1, 4, 2, //14
            -1, 4, 0, //15
            -1, 4, 0, //16
            1, 4, 0, //17
            1, 4, 2, //18
            -1, 4, 2, //19
            -1.5, 0.5, 0, //20
            0.5, 0.5, 0, //21
            0.5, 0.5, 2, //22
            -1.5, 0.5, 2, //23
            0.5, 0.5, 0, //24
            0.5, 0.5, 2, //25
            0.5, 1.5, 2, //26
            0.5, 1.5, 0, //27
            -1.5, 1.5, 0, //28
            0.5, 1.5, 0, //29
            0.5, 1.5, 2, //30
            -1.5, 1.5, 2, //31
            -1.5, 1.5, 0, //32
            -1.5, 1.5, 2, //33
            -1.5, 4.5, 2, //34
            -1.5, 4.5, 0, //35
            -1.5, 4.5, 0, //36
            1, 4.5, 0, //37
            1, 4.5, 2, //38
            -1.5, 4.5, 2, //39
            1, 4, 2, //40
            1, 4.5, 2, //41
            -1.5, 4, 2, //42
            -1.5, 4.5, 2, //43
            1, 4, 0, //44
            1, 4.5, 0, //45
            -1.5, 4, 0, //46
            -1.5, 4.5, 0, //47
            -1.5, 0, 2, //48
            1, 0, 2, //49
            1, 0.5, 2, //50
            -1.5, 0.5, 2, //51
            -1.5, 0, 0, //52
            1, 0, 0, //53
            1, 0.5, 0, //54
            -1.5, 0.5, 0, //55
            -1.5, 1.5, 0, //56
            1, 1.5, 0, //57
            1, 2, 0, //58
            -1.5, 2, 0, //59
            -1.5, 1.5, 2, //60
            1, 1.5, 2, //61
            1, 2, 2, //62
            -1.5, 2, 2, //63
            -1.5, 2, 2, //64
            -1, 2, 2, //65
            -1, 4, 2, //66
            -1.5, 4, 2, //67
            -1.5, 2, 0, //68
            -1, 2, 0, //69
            -1, 4, 0, //70
            -1.5, 4, 0, //71
            0.5, 1.5, 2, //72
            1, 1.5, 2, //73
            1, 0.5, 2, //74
            0.5, 0.5, 2, //75
            0.5, 1.5, 0, //76
            1, 1.5, 0, //77
            1, 0.5, 0, //78
            0.5, 0.5, 0, //79
            -1.5, 0, 2, //80
            -1.5, 0, 0, //81
            -1.5, 0.5, 0, //82
            -1.5, 0.5, 2, //83
            1, 4, 2, //84
            1, 4, 0, //85
            1, 4.5, 0, //86
            1, 4.5, 2 //87


             
        ])

        // Define Rubik's Cube colors for each face
        const planeColors = new Float32Array([
            192 / 255, 192 / 255, 192 / 255, 1.0, // R, G, B, Alpha
            192 / 255, 192 / 255, 192 / 255, 1.0,
            192 / 255, 192 / 255, 192 / 255, 1.0,
            192 / 255, 192 / 255, 192 / 255, 1.0,
        ]);

        const letterColors = new Float32Array([
            255 / 255, 182 / 255, 193 / 255, 1.0, // R, G, B, Alpha
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0, // R, G, B, Alpha
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0, // R, G, B, Alpha
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0, // R, G, B, Alpha
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0, // R, G, B, Alpha
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0, // R, G, B, Alpha
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0, // R, G, B, Alpha
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0, // R, G, B, Alpha
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0, // R, G, B, Alpha
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0, // R, G, B, Alpha
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0, // R, G, B, Alpha
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0, // R, G, B, Alpha
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0, // R, G, B, Alpha
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0, // R, G, B, Alpha
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0, // R, G, B, Alpha
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0, // R, G, B, Alpha
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0, // R, G, B, Alpha
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0, // R, G, B, Alpha
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0, // R, G, B, Alpha
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0, // R, G, B, Alpha
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0, // R, G, B, Alpha
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0, // R, G, B, Alpha
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
            255 / 255, 182 / 255, 193 / 255, 1.0,
        ]);

        const planeNormals = new Float32Array([
            // Top face
            0.0, 1.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 1.0, 0.0,
        ]);

        const letterNormals = new Float32Array([
            // Front face
            0.0, 0.0, 2.0,
            0.0, 0.0, 2.0,
            0.0, 0.0, 2.0,
            0.0, 0.0, 2.0,

            // Back face
            0.0, 0.0, -1.0,
            0.0, 0.0, -1.0,
            0.0, 0.0, -1.0,
            0.0, 0.0, -1.0,

            // Left face
            -2.0, 0.0, 0.0,
            -2.0, 0.0, 0.0,
            -2.0, 0.0, 0.0,
            -2.0, 0.0, 0.0,

            // Right face
            2.0, 0.0, 0.0,
            2.0, 0.0, 0.0,
            2.0, 0.0, 0.0,
            2.0, 0.0, 0.0,

            // Top face
            0.0, 3.0, 0.0,
            0.0, 3.0, 0.0,
            0.0, 3.0, 0.0,
            0.0, 3.0, 0.0,

            // Bottom face
            0.0, -2.0, 0.0,
            0.0, -2.0, 0.0,
            0.0, -2.0, 0.0,
            0.0, -2.0, 0.0,
                        // Front face
                        0.0, 0.0, 2.0,
            0.0, 0.0, 2.0,
            0.0, 0.0, 2.0,
            0.0, 0.0, 2.0,

            // Back face
            0.0, 0.0, -1.0,
            0.0, 0.0, -1.0,
            0.0, 0.0, -1.0,
            0.0, 0.0, -1.0,

            // Left face
            -2.0, 0.0, 0.0,
            -2.0, 0.0, 0.0,
            -2.0, 0.0, 0.0,
            -2.0, 0.0, 0.0,

            // Right face
            2.0, 0.0, 0.0,
            2.0, 0.0, 0.0,
            2.0, 0.0, 0.0,
            2.0, 0.0, 0.0,

            // Top face
            0.0, 3.0, 0.0,
            0.0, 3.0, 0.0,
            0.0, 3.0, 0.0,
            0.0, 3.0, 0.0,

            // Bottom face
            0.0, -2.0, 0.0,
            0.0, -2.0, 0.0,
            0.0, -2.0, 0.0,
            0.0, -2.0, 0.0,
                        // Front face
                        0.0, 0.0, 2.0,
            0.0, 0.0, 2.0,
            0.0, 0.0, 2.0,
            0.0, 0.0, 2.0,

            // Back face
            0.0, 0.0, -1.0,
            0.0, 0.0, -1.0,
            0.0, 0.0, -1.0,
            0.0, 0.0, -1.0,

            // Left face
            -2.0, 0.0, 0.0,
            -2.0, 0.0, 0.0,
            -2.0, 0.0, 0.0,
            -2.0, 0.0, 0.0,

            // Right face
            2.0, 0.0, 0.0,
            2.0, 0.0, 0.0,
            2.0, 0.0, 0.0,
            2.0, 0.0, 0.0,

            // Top face
            0.0, 3.0, 0.0,
            0.0, 3.0, 0.0,
            0.0, 3.0, 0.0,
            0.0, 3.0, 0.0,

            // Bottom face
            0.0, -2.0, 0.0,
            0.0, -2.0, 0.0,
            0.0, -2.0, 0.0,
            0.0, -2.0, 0.0,
                        // Front face
                        0.0, 0.0, 2.0,
            0.0, 0.0, 2.0,
            0.0, 0.0, 2.0,
            0.0, 0.0, 2.0,

            // Back face
            0.0, 0.0, -1.0,
            0.0, 0.0, -1.0,
            0.0, 0.0, -1.0,
            0.0, 0.0, -1.0,

            // Left face
            -2.0, 0.0, 0.0,
            -2.0, 0.0, 0.0,
            -2.0, 0.0, 0.0,
            -2.0, 0.0, 0.0,

            // Right face
            2.0, 0.0, 0.0,
            2.0, 0.0, 0.0,
            2.0, 0.0, 0.0,
            2.0, 0.0, 0.0,

            // Top face
            0.0, 3.0, 0.0,
            0.0, 3.0, 0.0,
            0.0, 3.0, 0.0,
            0.0, 3.0, 0.0,

            // Bottom face
            0.0, -2.0, 0.0,
            0.0, -2.0, 0.0,
            0.0, -2.0, 0.0,
            0.0, -2.0, 0.0,



        ]);


        // Define cube faces (using indices)
        const planeIndices = new Uint16Array([
            0, 1, 2, 0, 2, 3,   // Front face
        ]);

        const letterIndices = new Uint16Array([
            0, 1, 2, 0, 2, 3,   // Front face
            4, 5, 6, 4, 6, 7,   // Back face
            8,9,10, 8, 10, 11,
            12, 13, 14, 12, 14, 15,
            16,17,18, 16, 18, 19,
            20,21,22, 20, 22, 23,
            24,25,26, 24, 26, 27,
            28, 29, 30, 28, 30, 31,
            32, 33, 34, 32, 34, 35,
            36, 37, 38, 36, 38, 39,
            40, 41, 42, 41, 42, 43,
            44, 45, 46, 45, 46, 47,
            48, 49, 50, 48, 50, 51,
            52, 53, 54, 52, 54, 55,
            56, 57, 58, 56, 58, 59,
            60, 61, 62, 60, 62, 63,
            64, 65, 66, 64, 66, 67,
            68, 69, 70, 68, 70, 71,
            72, 73, 74, 72, 74, 75,
            76, 77, 78, 76, 78, 79,
            80, 81, 82, 80, 82, 83,
            84, 85, 86, 84, 86, 87


        ])

        // Define vertex shader source code
        const vertexShaderSource = `
            attribute vec4 a_position;
            attribute vec4 a_color;
            attribute vec3 a_normal;
            varying vec3 v_normal;
            varying vec4 v_color;
            varying vec3 v_fragPos; // Pass the fragment position to the fragment shader
            uniform mat4 u_modelMatrix;
            uniform mat4 u_modelViewProjectionMatrix;

            void main() {
                gl_Position = u_modelViewProjectionMatrix * a_position;
                v_color = a_color;
                v_normal = mat3(u_modelMatrix) * a_normal; // Transform normal to world space
                v_fragPos = (u_modelMatrix * a_position).xyz; // Transform fragment position
            }
        `;

        // Define fragment shader source code
        const fragmentShaderSource = `
            precision mediump float;
            varying vec4 v_color;
            varying vec3 v_normal;
            varying vec3 v_fragPos;
            uniform vec3 uAmbientColor;
            uniform vec3 u_directionalLightDirection; // Direction of the directional light
            uniform vec3 u_directionalLightColor; // Color of the directional light
            uniform vec3 u_pointLightPosition; // Position of the point light
            uniform vec3 u_pointLightColor;    // Color of the point light
            uniform float u_pointLightIntensity; // Intensity of the point light
            uniform vec3 u_cameraPosition; // Add this uniform for specular calculations
            uniform float u_angle;
            uniform float u_materialShininess; // Shininess of the material

            void main() {
                float sind = sin(u_angle);
                float cosd = cos(u_angle);
                // Normalize the normal vector
                vec3 normal = normalize(v_normal);
                vec3 viewDir = normalize(u_cameraPosition - v_fragPos);

                // Directional light direction
                vec3 lightDirection = normalize(u_directionalLightDirection);
                // Calculate the dot product between the normal and light direction
                float dotProduct = max(dot(normal, lightDirection), 0.0);
                // Calculate the final color with directional lighting
                vec3 diffuseColorDirectional = u_directionalLightColor * dotProduct;

                // Calculate the vector from the fragment position to the point light position
                vec3 lightDir = normalize(u_pointLightPosition - v_fragPos);
                // Calculate the diffuse lighting contribution
                float diff = max(dot(normal, lightDir), 0.0);
                // Calculate the final color with point light lighting
                vec3 diffuseColorPoint = u_pointLightColor * diff * u_pointLightIntensity;

                // Specular lighting calculations
                vec3 lightDirSpecular = normalize(-u_directionalLightDirection);
                vec3 reflectedDir = reflect(-lightDirSpecular, normal);
                float specular = pow(max(dot(viewDir, reflectedDir), 0.0), u_materialShininess);
                // Combine ambient, diffuse, and specular lighting
                vec3 lightColor = uAmbientColor + diffuseColorDirectional + diffuseColorPoint + (u_directionalLightColor * specular);
                gl_FragColor = vec4(lightColor * v_color.rgb, v_color.a);
            }
        `;

        // Compile and link shaders
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vertexShaderSource);
        gl.compileShader(vertexShader);

        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fragmentShaderSource);
        gl.compileShader(fragmentShader);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        // Specify attribute and uniform locations
        const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');
        const colorAttributeLocation = gl.getAttribLocation(program, 'a_color');
        const normalAttributeLocation = gl.getAttribLocation(program, 'a_normal');
        const modelMatrixLocation = gl.getUniformLocation(program, 'u_modelMatrix');
        const modelViewProjectionMatrixLocation = gl.getUniformLocation(program, 'u_modelViewProjectionMatrix');

        // Set up a perspective projection matrix
        const projectionMatrix = mat4.create();
        const fieldOfView = Math.PI / 4; // 45 degrees
        const aspect = canvas.width / canvas.height;
        const zNear = 0.1;
        const zFar = 100.0;
        mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);

        // Set up the view matrix (camera position and orientation)
        const viewMatrix = mat4.create();
        const cameraPosition = vec3.fromValues(0, 5, 20.0); // Adjust the camera position
        const targetPosition = vec3.fromValues(0.0, 0.0, 0.0); // Point the camera at the origin
        const upVector = vec3.fromValues(0.0, 1.0, 0.0); // Define the up vector
        mat4.lookAt(viewMatrix, cameraPosition, targetPosition, upVector);

        // Combine the view matrix with the projection matrix
        const viewProjectionMatrix = mat4.create();
        mat4.multiply(viewProjectionMatrix, projectionMatrix, viewMatrix);

        // Varibles for lighting and shading
        const ambientColor = vec3.fromValues(0.2, 0.2, 0.2);  // [0.2, 0.2, 0.2];
        const ambientColorLocation = gl.getUniformLocation(program, "uAmbientColor");// Get the uniform locations for directional light direction and color
        const directionalLightDirectionLocation = gl.getUniformLocation(program, 'u_directionalLightDirection');
        const directionalLightColorLocation = gl.getUniformLocation(program, 'u_directionalLightColor');
        const pointLightPositionLocation = gl.getUniformLocation(program, 'u_pointLightPosition');
        const pointLightColorLocation = gl.getUniformLocation(program, 'u_pointLightColor');
        const pointLightIntensityLocation = gl.getUniformLocation(program, 'u_pointLightIntensity');
        const materialShininessLocation = gl.getUniformLocation(program, 'u_materialShininess');
        const cameraPositionLocation = gl.getUniformLocation(program, 'u_cameraPosition');

        gl.uniform3fv(ambientColorLocation, ambientColor);
        gl.uniform3fv(cameraPositionLocation, cameraPosition);

        // Set the directional light direction (as a normalized vector)
        const directionalLightDirection = [0.0, 1.0, 0.0]; //[0.5, -0.5, -0.5]; // Adjust the direction as needed
        gl.uniform3fv(directionalLightDirectionLocation, directionalLightDirection);

        // Set the directional light color (as an RGB value)
        const directionalLightColor = [0.3, 0.3, 0.3]; // Adjust the color as needed
        gl.uniform3fv(directionalLightColorLocation, directionalLightColor);

        // Set the point light position
        const pointLightPosition = [1.0, 2.0, 3.0]; // Adjust the position as needed
        gl.uniform3fv(pointLightPositionLocation, pointLightPosition);

        // Set the point light color (as an RGB value)
        const pointLightColor = [1.0, 1.0, 1.0]; // Adjust the color as needed
        gl.uniform3fv(pointLightColorLocation, pointLightColor);

        // Set the point light intensity (adjust as needed)
        const pointLightIntensity = 1.0; // Adjust the intensity as needed
        gl.uniform1f(pointLightIntensityLocation, pointLightIntensity);

        // Set the material shininess (adjust as needed)
        const materialShininess = 200.0; // Adjust the shininess value
        gl.uniform1f(materialShininessLocation, materialShininess);

        // Variables for animation
        const translationSpeed = 0.1;
        let angle = 0.0;
        const angularSpeed = 0.01;
        const angleUniformLocation = gl.getUniformLocation(program, 'u_angle');
        let rotateZMatrix = mat4.create();
        const traslationSpeed = 0.1;

      // Transformation matrix
        const rotateZUniformLocation = gl.getUniformLocation(program, 'u_rotateZ');
        // Capture the event from the keyboard
        let d = [0.0, 0.0];
        let j = 0.0;
        let jump = 0;
        const dUniformLocation = gl.getUniformLocation(program, 'u_d');
        const jUniformLocation = gl.getUniformLocation(program, 'u_j');
        document.addEventListener('keydown', (event) => {
            const key = event.key;
            switch (key) {
                case 'w':
                    d[1] -= translationSpeed; // Move forward
                    break;
                case 's':
                    d[1] += translationSpeed; // Move backward
                    break;
                case 'a':
                    d[0] -= translationSpeed; // Move left
                    break;
                case 'd':
                    d[0] += translationSpeed; // Move right
                    break;
                case 'e':
                    angle += 0.1; // Rotate

                    break;    
                case 'q':
                    angle -= 0.1; // Rotate

                    break; 
            }
        });

        // Transformation matrix
        let modelMatrix = mat4.create();
        let modelViewProjectionMatrix = mat4.create();

        function drawPlane() {
            // Create buffers for cube vertices and colors
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, planeVertices, gl.STATIC_DRAW);

            const colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, planeColors, gl.STATIC_DRAW);

            const normalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, planeNormals, gl.STATIC_DRAW);

            // Create a buffer for cube indices
            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, planeIndices, gl.STATIC_DRAW);

            // Set up attribute pointers
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(positionAttributeLocation);
            gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.enableVertexAttribArray(colorAttributeLocation);
            gl.vertexAttribPointer(colorAttributeLocation, 4, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
            gl.enableVertexAttribArray(normalAttributeLocation);
            gl.vertexAttribPointer(normalAttributeLocation, 3, gl.FLOAT, false, 0, 0);

        
            mat4.multiply(modelViewProjectionMatrix, viewProjectionMatrix, modelMatrix);

            // Pass the modelMatrix to shaders as a uniform
            gl.uniformMatrix4fv(modelMatrixLocation, false, modelMatrix);

            // Pass the modelViewProjectionMatrix to your shaders as a uniform
            gl.uniformMatrix4fv(modelViewProjectionMatrixLocation, false, modelViewProjectionMatrix);

            gl.drawElements(gl.TRIANGLES, planeIndices.length, gl.UNSIGNED_SHORT, 0);
        }

        function drawLetter() {
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, letterVertices, gl.STATIC_DRAW);

            const colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, letterColors, gl.STATIC_DRAW);

            const normalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, letterNormals, gl.STATIC_DRAW);

            // Create a buffer for cube indices
            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, letterIndices, gl.STATIC_DRAW);

            // Set up attribute pointers
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(positionAttributeLocation);
            gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.enableVertexAttribArray(colorAttributeLocation);
            gl.vertexAttribPointer(colorAttributeLocation, 4, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
            gl.enableVertexAttribArray(normalAttributeLocation);
            gl.vertexAttribPointer(normalAttributeLocation, 3, gl.FLOAT, false, 0, 0);

            // Variables for animation
            const translationSpeed = 0.1;
            const angularSpeed = 0.01;

            // Transformation matrix
            let modelMatrix = mat4.create();
            let modelViewProjectionMatrix = mat4.create();
            angle += angularSpeed;
            mat4.rotateZ(modelMatrix, mat4.create(), angle);
            mat4.rotateY(modelMatrix, modelMatrix, angle);
            mat4.rotateX(modelMatrix, modelMatrix, angle);
            mat4.translate(modelMatrix, mat4.create(), [d[0], 0.0, d[1]]);
            mat4.multiply(modelViewProjectionMatrix, viewProjectionMatrix, modelMatrix);
            if (jump === 1) {
                j += 2;
            if (j >= 1) {
                jump = 0; 
            }
            } else if (j > 0) {
                j -= 1;
            }
            gl.uniform1f(jUniformLocation, j);
            // Pass the modelMatrix to shaders as a uniform
            gl.uniformMatrix4fv(modelMatrixLocation, false, modelMatrix);

            // Pass the modelViewProjectionMatrix to your shaders as a uniform
            gl.uniformMatrix4fv(modelViewProjectionMatrixLocation, false, modelViewProjectionMatrix);

            gl.drawElements(gl.TRIANGLES, letterIndices.length, gl.UNSIGNED_SHORT, 0);
        }
        function drawScene() {
            // Rendering loop
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.enable(gl.DEPTH_TEST);
            gl.viewport(0, 0, canvas.width, canvas.height);
            // Enable blending or transparency
            //gl.enable(gl.BLEND);
            // Set the blend function (commonly used for transparency)
            //gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            // Clear canvas
            gl.clear(gl.COLOR_BUFFER_BIT);

            drawPlane();


            drawLetter();

            requestAnimationFrame(drawScene);
        }

        // Start the rendering loop
        drawScene();

    </script>
</body>

</html>