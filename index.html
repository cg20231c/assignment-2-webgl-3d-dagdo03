<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <title>5025211231</title>
    <style>
        canvas { width: 100%; height: 100% }
        body { margin: 0; overflow: hidden; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.4.0/gl-matrix.js"></script>
</head>
<body>
    <canvas id="webglCanvas"></canvas>
    <script>
      let canvas = document.getElementById('webglCanvas');
      let gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
      
      if (!gl) {
          alert('WebGL is not supported by this browser.');
      }
    // Define vertex shader source code
        const vertexShaderSource = `
            attribute vec4 a_position;
            attribute vec4 a_color;
            varying vec4 v_color;
            uniform mat4 u_viewprojectionMatrix;

            void main() {
                gl_Position = u_viewprojectionMatrix * a_position;
                v_color = a_color;
            }
        `;

        // Define fragment shader source code
        const fragmentShaderSource = `
            precision mediump float;
            varying vec4 v_color;

            void main() {
                gl_FragColor = v_color;
            }
        `;

      
      // Shader sources
    //   let vertexShaderSource = `
    //       attribute vec4 aPosition;
    //       void main() {
    //           gl_Position = aPosition;
    //       }
    //   `;
      
    //   let fragmentShaderSource = `
    //       precision mediump float;
    //       void main() {
    //           gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
    //       }
    //   `;
      
      // WebGL initialization, shaders, and utility functions
      // ... 
      
      // Plane construction
        // Define cube vertices
        const cubeVertices = new Float32Array([
            // Bottom face
            -1.0, -1.0, -1.0,
            1.0, -1.0, -1.0,
            1.0, -1.0,  1.0,
            -1.0, -1.0,  1.0,
        ]);

        // Define Rubik's Cube colors for each face
        const cubeColors = new Float32Array([
            // Bottom face (Silver)
            0.75, 0.75, 0.75, 1.0,
            0.75, 0.75, 0.75, 1.0,
            0.75, 0.75, 0.75, 1.0,
            0.75, 0.75, 0.75, 1.0,
        ]);

        // Define cube faces (using indices)
        const cubeIndices = new Uint16Array([
            0, 1, 2, 0, 2, 3    // Bottom face
        ]);


        // Compile and link shaders
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vertexShaderSource);
        gl.compileShader(vertexShader);

        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fragmentShaderSource);
        gl.compileShader(fragmentShader);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        // Create buffers for cube vertices and colors
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, cubeVertices, gl.STATIC_DRAW);

        const colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, cubeColors, gl.STATIC_DRAW);

        // Create a buffer for cube indices
        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cubeIndices, gl.STATIC_DRAW);

        // Specify attribute and uniform locations
        const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');
        const colorAttributeLocation = gl.getAttribLocation(program, 'a_color');
        const viewProjectionMatrixLocation = gl.getUniformLocation(program, 'u_viewprojectionMatrix');

        // Set up attribute pointers
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.enableVertexAttribArray(positionAttributeLocation);
        gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.enableVertexAttribArray(colorAttributeLocation);
        gl.vertexAttribPointer(colorAttributeLocation, 4, gl.FLOAT, false, 0, 0);

        // Set up a perspective projection matrix
        const projectionMatrix = mat4.create();
        const fieldOfView = Math.PI / 4; // 45 degrees
        const aspect = canvas.width / canvas.height;
        const zNear = 0.1;
        const zFar = 100.0;
        mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);
        
        // Set up the view matrix (camera position and orientation)
        const viewMatrix = mat4.create();
        const cameraPosition = vec3.fromValues(2.0, 2.0, 5.0); // Adjust the camera position
        const targetPosition = vec3.fromValues(0.0, 0.0, 0.0); // Point the camera at the origin
        const upVector = vec3.fromValues(0.0, 1.0, 0.0); // Define the up vector
        mat4.lookAt(viewMatrix, cameraPosition, targetPosition, upVector);

        // Combine the view matrix with the projection matrix
        const viewProjectionMatrix = mat4.create();
        mat4.multiply(viewProjectionMatrix, projectionMatrix, viewMatrix);

        // Pass the viewProjectionMatrix to your shaders as a uniform
        gl.uniformMatrix4fv(viewProjectionMatrixLocation, false, viewProjectionMatrix);

        function drawPlane() {
            //const currentTime = performance.now();
            //const elapsedTime = (currentTime - startTime) / 1000.0; // Convert to seconds

            // Pass the elapsed time to the fragment shader as a uniform
            //const timeUniformLocation = gl.getUniformLocation(program, 'u_time');
            //gl.uniform1f(timeUniformLocation, elapsedTime);

            // Clear canvas
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.enable(gl.DEPTH_TEST);
            gl.viewport(0, 0, canvas.width, canvas.height);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.drawElements(gl.TRIANGLES, cubeIndices.length, gl.UNSIGNED_SHORT, 0);

            requestAnimationFrame(drawPlane);
        }
      // Main rendering function
      function drawScene() {
          // Clear the canvas
          gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black
          gl.clearDepth(1.0);
          gl.enable(gl.DEPTH_TEST);
          gl.depthFunc(gl.LEQUAL);
          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      
          // Set perspective view
          mat4.perspective(projectionMatrix, Math.PI / 4, canvas.width / canvas.height, 0.1, 100.0);
      
          // Set camera position and view
          // ... (camera setting logic here)
      
          // Draw the plane
          drawPlane();
      
          // Draw the 3D letter
          drawLetter();
      
          // Draw the illuminated cube
          drawIlluminatedCube();
      
          // Any other objects and logic can be added here
      
          // Loop for animations
          requestAnimationFrame(drawScene);
      }
      
      // Start the rendering loop
      drawScene();

    </script>
</body>
</html>
